{"ast":null,"code":"var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"kind\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { useAnalytics } from '../../contexts';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { useForwardedRef } from '../../utils';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n  if (match) {\n    var arrayName = match[1],\n      indexOfArray = match[2],\n      arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n  return undefined;\n};\nvar getValueAt = function getValueAt(valueObject, pathArg) {\n  if (valueObject === undefined) return undefined;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) return valueObject[path];\n  return getValueAt(valueObject[path.shift()], path);\n};\nvar setValueAt = function setValueAt(valueObject, pathArg, value) {\n  var object = valueObject;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) object[path] = value;else {\n    var key = path.shift();\n    if (!object[key]) object[key] = {};\n    setValueAt(object[key], path, value);\n  }\n};\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var _value$arrayName;\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n  return getValueAt(value, name);\n};\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    setValueAt(nextValue, name, componentValue);\n  }\n  return nextValue;\n};\n\n// Apply validation rule to field value and send correct messaging.\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n  return result;\n};\n\n// Validates particular key in formValue\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n    if (required && (\n    // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n    return validationResult;\n  };\n};\n\n// Validates all keys in formValue\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n      _ref$ = _ref[1],\n      field = _ref$.field,\n      input = _ref$.input,\n      validateOn = _ref$.validateOn;\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n    if (!validateOn) return;\n    var result;\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    }\n    // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\nvar isInstantValidate = function isInstantValidate(validateOn) {\n  return ['blur', 'change'].includes(validateOn);\n};\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n    _ref2$errors = _ref2.errors,\n    errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n    _ref2$infos = _ref2.infos,\n    infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n    messages = _ref2.messages,\n    kind = _ref2.kind,\n    onChange = _ref2.onChange,\n    _onReset = _ref2.onReset,\n    _onSubmit = _ref2.onSubmit,\n    onValidate = _ref2.onValidate,\n    _ref2$validate = _ref2.validate,\n    validateOnProp = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n    valueProp = _ref2.value,\n    rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n  var formRef = useForwardedRef(ref);\n  var _useContext = useContext(MessageContext),\n    format = _useContext.format;\n  var _useState = useState(valueProp || defaultValue),\n    valueState = _useState[0],\n    setValueState = _useState[1];\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n  var _useState2 = useState(defaultTouched),\n    touched = _useState2[0],\n    setTouched = _useState2[1];\n  var _useState3 = useState(validateOnProp),\n    validateOn = _useState3[0],\n    setValidateOn = _useState3[1];\n  var _useState4 = useState({\n      errors: errorsProp,\n      infos: infosProp\n    }),\n    validationResults = _useState4[0],\n    setValidationResults = _useState4[1];\n  // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n  var validationResultsRef = useRef({});\n  // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n  var _useState5 = useState('unmounted'),\n    mounted = _useState5[0],\n    setMounted = _useState5[1];\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]);\n  // `pendingValidation` is the name of the FormField awaiting validation.\n  var _useState6 = useState(undefined),\n    pendingValidation = _useState6[0],\n    setPendingValidation = _useState6[1];\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var analyticsRef = useRef({\n    start: new Date(),\n    errors: {}\n  });\n  var sendAnalytics = useAnalytics();\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]);\n\n  // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n  var updateAnalytics = function updateAnalytics() {\n    var _validationResultsRef;\n    var errorFields = Object.keys((_validationResultsRef = validationResultsRef.current) == null ? void 0 : _validationResultsRef.errors);\n    var errorCounts = analyticsRef.current.errors;\n    if (errorFields.length > 0) {\n      errorFields.forEach(function (key) {\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n    }\n  };\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n      validatedErrors = _validateForm[0],\n      validatedInfos = _validateForm[1];\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n      // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      updateAnalytics();\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]);\n\n  // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n    if (mounted !== 'mounted' && (isInstantValidate(validateOn) || validationRules.some(function (_ref3) {\n      var v = _ref3[1];\n      return isInstantValidate(v.validateOn);\n    })) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref4) {\n        var n = _ref4[0],\n          v = _ref4[1];\n        return getFieldValue(n, value) && v.validateOn;\n      })\n      // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref5) {\n        var n = _ref5[0];\n        return !(Array.isArray(getFieldValue(n, value)) && getFieldValue(n, value).length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]);\n\n  // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && (isInstantValidate(validateOn) || validationRules.some(function (_ref6) {\n        var v = _ref6[1];\n        return isInstantValidate(v.validateOn);\n      }))) {\n        applyValidationRules(validationRules.filter(function (_ref7) {\n          var n = _ref7[0],\n            v = _ref7[1];\n          return (touched[n] || pendingValidation.includes(n)) && v.validateOn;\n        }));\n        setPendingValidation(undefined);\n      }\n      // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]);\n\n  // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n  useEffect(function () {\n    var _validationResultsRef2;\n    var validationRules = Object.entries(validationRulesRef.current);\n    if ((_validationResultsRef2 = validationResultsRef.current) != null && _validationResultsRef2.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref8) {\n        var n = _ref8[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]);\n  useEffect(function () {\n    var element = formRef.current;\n    analyticsRef.current = {\n      start: new Date(),\n      errors: {}\n    };\n    sendAnalytics({\n      type: 'formOpen',\n      element: element\n    });\n    return function () {\n      if (!analyticsRef.current.submitted) {\n        sendAnalytics({\n          type: 'formClose',\n          element: element,\n          errors: analyticsRef.current.errors,\n          elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n        });\n      }\n    };\n  }, [sendAnalytics, formRef]);\n\n  // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref9) {\n      var name = _ref9.name,\n        componentValue = _ref9.value,\n        initialValue = _ref9.initialValue,\n        validateArg = _ref9.validate;\n      var _useState7 = useState(initialValue),\n        inputValue = _useState7[0],\n        setInputValue = _useState7[1];\n      var formValue = name ? getFieldValue(name, value) : undefined;\n      // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n      var keyCreated = useRef(false);\n\n      // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n      useEffect(function () {\n        if (name &&\n        // we have somewhere to put this\n        componentValue !== undefined && (\n        // input driving\n        Array.isArray(componentValue) && Array.isArray(formValue) ? componentValue.toString() !== formValue.toString() : componentValue !== formValue) // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          });\n          // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]);\n\n      // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n              var isArrayField = stringToArray(name);\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n              return nextValue;\n            });\n          }\n        };\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      );\n\n      // Create validation rules for fields\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined)\n        // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined)\n        // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name)\n        // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n          nextTouched[name] = true;\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          }\n\n          // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n    var useFormField = function useFormField(_ref10) {\n      var errorArg = _ref10.error,\n        infoArg = _ref10.info,\n        name = _ref10.name,\n        required = _ref10.required,\n        disabled = _ref10.disabled,\n        validateArg = _ref10.validate,\n        validateOnArg = _ref10.validateOn;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name];\n      useEffect(function () {\n        setValidateOn(function (prevValues) {\n          var _extends2;\n          if (typeof prevValues === 'string') {\n            var _ref11;\n            return _ref11 = {}, _ref11[name] = validateOnArg || validateOnProp, _ref11;\n          }\n          return _extends({}, prevValues, (_extends2 = {}, _extends2[name] = validateOnArg || validateOnProp, _extends2));\n        });\n      }, [validateOnArg, name]);\n\n      // Create validation rules for field\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n\n          // priority is given to validateOn prop on formField, if it is\n          // undefined, then we will use the validate prop value of Form.\n          // The reason we don't want to add validateOn = \"submit\" here is\n          // because we don't want to trigger validation of \"submit\" field\n          // when the user is typing in the instant (blur, change)\n          // validation fields.\n          if (validateOnArg && validateOnArg !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnArg;\n          } else if (!validateOnArg && validateOnProp !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnProp;\n          }\n          return function () {\n            delete validationRulesRef.current[name].field;\n            delete validationRulesRef.current[name].validateOn;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n        return undefined;\n      }, [error, name, required, validateArg, disabled, validateOnArg]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOnArg === 'blur' || validateOn[name] === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOnArg === 'change' || validateOn[name] === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput,\n      kind: kind\n    };\n  }, [onChange, kind, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp, validateOnProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: formRef\n  }, rest, {\n    onReset: function onReset(event) {\n      sendAnalytics({\n        type: 'formReset',\n        element: formRef.current,\n        data: event,\n        errors: analyticsRef.current.errors,\n        elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n      });\n      setPendingValidation(undefined);\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n      analyticsRef.current = {\n        start: new Date(),\n        errors: {}\n      };\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      // Prevent any \"outer\" forms from performing `onSubmit`.\n      // Nesting forms is not recommended in HTML. However, with React\n      // portals, if the portal (such as Grommet's Layer) contains a form\n      // and is nested within another form in the React tree, the event\n      // bubbles up to the \"outer\" form even though in the DOM the portal\n      // doesn't render as child of the \"outer\" form.\n      // https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals\n      if (formRef.current && event.target === formRef.current) {\n        setPendingValidation(undefined);\n        // adding validateOn: \"submit\" prop to the undefined validateOn\n        // fields as we want to trigger \"submit\" validation once form\n        // is submitted\n        var newValidationRulesRef = Object.keys(validationRulesRef.current).reduce(function (acc, key) {\n          acc[key] = validationRulesRef.current[key];\n          if (!acc[key].validateOn) {\n            acc[key] = _extends({}, validationRulesRef.current[key], {\n              validateOn: 'submit'\n            });\n          }\n          return acc;\n        }, {});\n        var _validateForm2 = validateForm(Object.entries(newValidationRulesRef), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n        setValidationResults(function () {\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            // Show form's validity when clicking on Submit\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          validationResultsRef.current = nextValidationResults;\n          updateAnalytics();\n          return nextValidationResults;\n        });\n        if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n          event.persist(); // extract from React's synthetic event pool\n          var adjustedEvent = event;\n          adjustedEvent.value = value;\n          adjustedEvent.touched = touched;\n          _onSubmit(adjustedEvent);\n          sendAnalytics({\n            type: 'formSubmit',\n            element: formRef.current,\n            data: adjustedEvent,\n            errors: analyticsRef.current.errors,\n            elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n          });\n          analyticsRef.current.errors = {};\n          analyticsRef.current.submitted = true;\n        }\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };","map":{"version":3,"names":["_excluded","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","bind","arguments","prototype","hasOwnProperty","call","apply","React","forwardRef","useCallback","useContext","useEffect","useMemo","useRef","useState","useAnalytics","MessageContext","useForwardedRef","FormContext","FormPropTypes","defaultValue","defaultTouched","defaultValidationResults","errors","infos","stringToArray","string","match","arrayName","indexOfArray","arrayObjName","undefined","getValueAt","valueObject","pathArg","path","Array","isArray","split","shift","setValueAt","value","object","getFieldValue","name","isArrayField","_value$arrayName","obj","setFieldValue","componentValue","prevValue","nextValue","_nextValue$arrayName$","validate","rule","fieldValue","formValue","format","messages","result","regexp","test","message","id","status","validateName","validationRules","required","validationResult","some","validateForm","omitValid","nextErrors","nextInfos","forEach","_ref","_ref$","field","input","validateOn","isInstantValidate","includes","Form","_ref2","ref","children","_ref2$errors","errorsProp","_ref2$infos","infosProp","kind","onChange","_onReset","onReset","_onSubmit","onSubmit","onValidate","_ref2$validate","validateOnProp","valueProp","rest","formRef","_useContext","_useState","valueState","setValueState","_useState2","touched","setTouched","_useState3","setValidateOn","_useState4","validationResults","setValidationResults","validationResultsRef","_useState5","mounted","setMounted","_useState6","pendingValidation","setPendingValidation","validationRulesRef","requiredFields","analyticsRef","start","Date","sendAnalytics","buildValid","valid","current","filter","n","every","filterRemovedFields","prevValidations","nextValidations","updateAnalytics","_validationResultsRef","errorFields","errorCounts","applyValidationRules","_validateForm","validatedErrors","validatedInfos","prevValidationResults","nextValidationResults","entries","_ref3","v","_ref4","_ref5","timer","setTimeout","_ref6","_ref7","clearTimeout","_validationResultsRef2","_ref8","element","type","submitted","elapsed","getTime","formContextValue","useFormInput","_ref9","initialValue","validateArg","_useState7","inputValue","setInputValue","keyCreated","toString","useValue","nextComponentValue","nextTouched","useFormField","_ref10","errorArg","error","infoArg","info","disabled","validateOnArg","prevValues","_extends2","_ref11","index","push","splice","requiredFieldIndex","inForm","onBlur","concat","createElement","event","data","persist","adjustedEvent","preventDefault","newValidationRulesRef","reduce","acc","_validateForm2","Provider","displayName","propTypes"],"sources":["/Users/kyle/projects/personal/hpe-react-practice/node_modules/grommet/es6/components/Form/Form.js"],"sourcesContent":["var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"kind\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { useAnalytics } from '../../contexts';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { useForwardedRef } from '../../utils';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n  if (match) {\n    var arrayName = match[1],\n      indexOfArray = match[2],\n      arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n  return undefined;\n};\nvar getValueAt = function getValueAt(valueObject, pathArg) {\n  if (valueObject === undefined) return undefined;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) return valueObject[path];\n  return getValueAt(valueObject[path.shift()], path);\n};\nvar setValueAt = function setValueAt(valueObject, pathArg, value) {\n  var object = valueObject;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) object[path] = value;else {\n    var key = path.shift();\n    if (!object[key]) object[key] = {};\n    setValueAt(object[key], path, value);\n  }\n};\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var _value$arrayName;\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n  return getValueAt(value, name);\n};\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    setValueAt(nextValue, name, componentValue);\n  }\n  return nextValue;\n};\n\n// Apply validation rule to field value and send correct messaging.\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n  return result;\n};\n\n// Validates particular key in formValue\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n    if (required && (\n    // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n    return validationResult;\n  };\n};\n\n// Validates all keys in formValue\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n      _ref$ = _ref[1],\n      field = _ref$.field,\n      input = _ref$.input,\n      validateOn = _ref$.validateOn;\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n    if (!validateOn) return;\n    var result;\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    }\n    // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\nvar isInstantValidate = function isInstantValidate(validateOn) {\n  return ['blur', 'change'].includes(validateOn);\n};\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n    _ref2$errors = _ref2.errors,\n    errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n    _ref2$infos = _ref2.infos,\n    infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n    messages = _ref2.messages,\n    kind = _ref2.kind,\n    onChange = _ref2.onChange,\n    _onReset = _ref2.onReset,\n    _onSubmit = _ref2.onSubmit,\n    onValidate = _ref2.onValidate,\n    _ref2$validate = _ref2.validate,\n    validateOnProp = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n    valueProp = _ref2.value,\n    rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n  var formRef = useForwardedRef(ref);\n  var _useContext = useContext(MessageContext),\n    format = _useContext.format;\n  var _useState = useState(valueProp || defaultValue),\n    valueState = _useState[0],\n    setValueState = _useState[1];\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n  var _useState2 = useState(defaultTouched),\n    touched = _useState2[0],\n    setTouched = _useState2[1];\n  var _useState3 = useState(validateOnProp),\n    validateOn = _useState3[0],\n    setValidateOn = _useState3[1];\n  var _useState4 = useState({\n      errors: errorsProp,\n      infos: infosProp\n    }),\n    validationResults = _useState4[0],\n    setValidationResults = _useState4[1];\n  // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n  var validationResultsRef = useRef({});\n  // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n  var _useState5 = useState('unmounted'),\n    mounted = _useState5[0],\n    setMounted = _useState5[1];\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]);\n  // `pendingValidation` is the name of the FormField awaiting validation.\n  var _useState6 = useState(undefined),\n    pendingValidation = _useState6[0],\n    setPendingValidation = _useState6[1];\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var analyticsRef = useRef({\n    start: new Date(),\n    errors: {}\n  });\n  var sendAnalytics = useAnalytics();\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]);\n\n  // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n  var updateAnalytics = function updateAnalytics() {\n    var _validationResultsRef;\n    var errorFields = Object.keys((_validationResultsRef = validationResultsRef.current) == null ? void 0 : _validationResultsRef.errors);\n    var errorCounts = analyticsRef.current.errors;\n    if (errorFields.length > 0) {\n      errorFields.forEach(function (key) {\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n    }\n  };\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n      validatedErrors = _validateForm[0],\n      validatedInfos = _validateForm[1];\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n      // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      updateAnalytics();\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]);\n\n  // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n    if (mounted !== 'mounted' && (isInstantValidate(validateOn) || validationRules.some(function (_ref3) {\n      var v = _ref3[1];\n      return isInstantValidate(v.validateOn);\n    })) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref4) {\n        var n = _ref4[0],\n          v = _ref4[1];\n        return getFieldValue(n, value) && v.validateOn;\n      })\n      // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref5) {\n        var n = _ref5[0];\n        return !(Array.isArray(getFieldValue(n, value)) && getFieldValue(n, value).length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]);\n\n  // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && (isInstantValidate(validateOn) || validationRules.some(function (_ref6) {\n        var v = _ref6[1];\n        return isInstantValidate(v.validateOn);\n      }))) {\n        applyValidationRules(validationRules.filter(function (_ref7) {\n          var n = _ref7[0],\n            v = _ref7[1];\n          return (touched[n] || pendingValidation.includes(n)) && v.validateOn;\n        }));\n        setPendingValidation(undefined);\n      }\n      // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]);\n\n  // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n  useEffect(function () {\n    var _validationResultsRef2;\n    var validationRules = Object.entries(validationRulesRef.current);\n    if ((_validationResultsRef2 = validationResultsRef.current) != null && _validationResultsRef2.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref8) {\n        var n = _ref8[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]);\n  useEffect(function () {\n    var element = formRef.current;\n    analyticsRef.current = {\n      start: new Date(),\n      errors: {}\n    };\n    sendAnalytics({\n      type: 'formOpen',\n      element: element\n    });\n    return function () {\n      if (!analyticsRef.current.submitted) {\n        sendAnalytics({\n          type: 'formClose',\n          element: element,\n          errors: analyticsRef.current.errors,\n          elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n        });\n      }\n    };\n  }, [sendAnalytics, formRef]);\n\n  // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref9) {\n      var name = _ref9.name,\n        componentValue = _ref9.value,\n        initialValue = _ref9.initialValue,\n        validateArg = _ref9.validate;\n      var _useState7 = useState(initialValue),\n        inputValue = _useState7[0],\n        setInputValue = _useState7[1];\n      var formValue = name ? getFieldValue(name, value) : undefined;\n      // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n      var keyCreated = useRef(false);\n\n      // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n      useEffect(function () {\n        if (name &&\n        // we have somewhere to put this\n        componentValue !== undefined && (\n        // input driving\n        Array.isArray(componentValue) && Array.isArray(formValue) ? componentValue.toString() !== formValue.toString() : componentValue !== formValue) // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          });\n          // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]);\n\n      // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n              var isArrayField = stringToArray(name);\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n              return nextValue;\n            });\n          }\n        };\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      );\n\n      // Create validation rules for fields\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined)\n        // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined)\n        // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name)\n        // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n          nextTouched[name] = true;\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          }\n\n          // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n    var useFormField = function useFormField(_ref10) {\n      var errorArg = _ref10.error,\n        infoArg = _ref10.info,\n        name = _ref10.name,\n        required = _ref10.required,\n        disabled = _ref10.disabled,\n        validateArg = _ref10.validate,\n        validateOnArg = _ref10.validateOn;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name];\n      useEffect(function () {\n        setValidateOn(function (prevValues) {\n          var _extends2;\n          if (typeof prevValues === 'string') {\n            var _ref11;\n            return _ref11 = {}, _ref11[name] = validateOnArg || validateOnProp, _ref11;\n          }\n          return _extends({}, prevValues, (_extends2 = {}, _extends2[name] = validateOnArg || validateOnProp, _extends2));\n        });\n      }, [validateOnArg, name]);\n\n      // Create validation rules for field\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n\n          // priority is given to validateOn prop on formField, if it is\n          // undefined, then we will use the validate prop value of Form.\n          // The reason we don't want to add validateOn = \"submit\" here is\n          // because we don't want to trigger validation of \"submit\" field\n          // when the user is typing in the instant (blur, change)\n          // validation fields.\n          if (validateOnArg && validateOnArg !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnArg;\n          } else if (!validateOnArg && validateOnProp !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnProp;\n          }\n          return function () {\n            delete validationRulesRef.current[name].field;\n            delete validationRulesRef.current[name].validateOn;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n        return undefined;\n      }, [error, name, required, validateArg, disabled, validateOnArg]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOnArg === 'blur' || validateOn[name] === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOnArg === 'change' || validateOn[name] === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput,\n      kind: kind\n    };\n  }, [onChange, kind, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp, validateOnProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: formRef\n  }, rest, {\n    onReset: function onReset(event) {\n      sendAnalytics({\n        type: 'formReset',\n        element: formRef.current,\n        data: event,\n        errors: analyticsRef.current.errors,\n        elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n      });\n      setPendingValidation(undefined);\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n      analyticsRef.current = {\n        start: new Date(),\n        errors: {}\n      };\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      // Prevent any \"outer\" forms from performing `onSubmit`.\n      // Nesting forms is not recommended in HTML. However, with React\n      // portals, if the portal (such as Grommet's Layer) contains a form\n      // and is nested within another form in the React tree, the event\n      // bubbles up to the \"outer\" form even though in the DOM the portal\n      // doesn't render as child of the \"outer\" form.\n      // https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals\n      if (formRef.current && event.target === formRef.current) {\n        setPendingValidation(undefined);\n        // adding validateOn: \"submit\" prop to the undefined validateOn\n        // fields as we want to trigger \"submit\" validation once form\n        // is submitted\n        var newValidationRulesRef = Object.keys(validationRulesRef.current).reduce(function (acc, key) {\n          acc[key] = validationRulesRef.current[key];\n          if (!acc[key].validateOn) {\n            acc[key] = _extends({}, validationRulesRef.current[key], {\n              validateOn: 'submit'\n            });\n          }\n          return acc;\n        }, {});\n        var _validateForm2 = validateForm(Object.entries(newValidationRulesRef), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n        setValidationResults(function () {\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            // Show form's validity when clicking on Submit\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          validationResultsRef.current = nextValidationResults;\n          updateAnalytics();\n          return nextValidationResults;\n        });\n        if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n          event.persist(); // extract from React's synthetic event pool\n          var adjustedEvent = event;\n          adjustedEvent.value = value;\n          adjustedEvent.touched = touched;\n          _onSubmit(adjustedEvent);\n          sendAnalytics({\n            type: 'formSubmit',\n            element: formRef.current,\n            data: adjustedEvent,\n            errors: analyticsRef.current.errors,\n            elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n          });\n          analyticsRef.current.errors = {};\n          analyticsRef.current.submitted = true;\n        }\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}