{"ast":null,"code":"import { calcMinMax, normalizeValues } from './utils';\nvar thicknessPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall'\n};\nexport var round = function round(value, decimals) {\n  return Number(Math.round(value + \"e\" + decimals) + \"e-\" + decimals);\n};\n\n// Normalize coarseness to an object.\n// Backwards compatible has no coarseness for x-axis.\nvar normalizeCoarseness = function normalizeCoarseness(coarseness, direction) {\n  var result;\n  if (Array.isArray(coarseness)) result = {\n    x: coarseness[0],\n    y: coarseness[1]\n  };else if (typeof coarseness === 'object') result = coarseness;else if (coarseness) result = {\n    x: undefined,\n    y: coarseness\n  };else result = direction === 'horizontal' ? {\n    x: 5,\n    y: undefined\n  } : {\n    x: undefined,\n    y: 5\n  };\n  return result;\n};\nvar normalizeSteps = function normalizeSteps(steps) {\n  var result;\n  if (Array.isArray(steps)) result = {\n    x: steps[0],\n    y: steps[1]\n  };else if (typeof steps === 'object') result = steps;else result = {\n    x: 1,\n    y: 1\n  };\n  return result;\n};\nvar alignMax = function alignMax(value, interval) {\n  if (value > 0) return value - value % interval + interval;\n  if (value < 0) return value + value % interval;\n  return value;\n};\nvar alignMin = function alignMin(value, interval) {\n  if (value > 0) return value - value % interval;\n  if (value < 0) return value - value % interval - interval;\n  return value;\n};\nvar adjustToShowZero = function adjustToShowZero(minArg, maxArg, steps) {\n  var min = minArg;\n  var max = maxArg;\n  if (min < 0 && max > 0 && Math.abs(min) !== Math.abs(max)) {\n    // Adjust min and max when crossing 0 to ensure 0 will be shown on\n    // the axis based on the number of steps.\n    if (steps === 1) {\n      var largest = Math.max(Math.abs(min), Math.abs(max));\n      min = -largest;\n      max = largest;\n    } else {\n      var stepInterval = (max - min) / steps;\n      var minSteps = min / stepInterval;\n      var maxSteps = max / stepInterval;\n      if (Math.abs(minSteps) < Math.abs(maxSteps)) {\n        // more above than below\n        stepInterval = max / Math.floor(maxSteps);\n        max = stepInterval * Math.floor(maxSteps);\n        min = stepInterval * Math.floor(minSteps);\n      } else {\n        // more below than above\n        stepInterval = Math.abs(min / Math.ceil(minSteps));\n        min = stepInterval * Math.ceil(minSteps);\n        max = stepInterval * Math.ceil(maxSteps);\n      }\n    }\n  }\n  return [min, max];\n};\nexport var calcBounds = function calcBounds(valuesArg, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // coarseness influences the rounding of the bounds, the smaller the\n  // number, the more the bounds will be rounded. e.g. 111 -> 110 -> 100.\n  var _normalizeCoarseness = normalizeCoarseness(options.coarseness, options.direction),\n    coarseX = _normalizeCoarseness.x,\n    coarseY = _normalizeCoarseness.y;\n\n  // the number of steps is one less than the number of labels\n  var _normalizeSteps = normalizeSteps(options.steps),\n    stepsX = _normalizeSteps.x,\n    stepsY = _normalizeSteps.y;\n  var values = normalizeValues(valuesArg || []);\n  var result;\n  if (values.length) {\n    // min and max values\n    var _calcMinMax = calcMinMax(values, options.direction),\n      _calcMinMax$x = _calcMinMax.x,\n      minX = _calcMinMax$x.min,\n      maxX = _calcMinMax$x.max,\n      _calcMinMax$y = _calcMinMax.y,\n      minY = _calcMinMax$y.min,\n      maxY = _calcMinMax$y.max;\n\n    // Calculate some reasonable bounds based on the max and min values.\n    // This is so values like 87342.12 don't end up being displayed as the\n    // graph axis labels.\n    if (coarseX) {\n      var deltaX = maxX - minX;\n      var intervalX = Number.parseFloat((deltaX / coarseX).toPrecision(1));\n      minX = alignMin(minX, intervalX);\n      maxX = alignMax(maxX, intervalX);\n    }\n    if (coarseY) {\n      var deltaY = maxY - minY;\n      var intervalY = Number.parseFloat((deltaY / coarseY).toPrecision(1));\n      minY = alignMin(minY, intervalY);\n      maxY = alignMax(maxY, intervalY);\n    }\n    if (options.direction === 'horizontal') {\n      var _adjustToShowZero = adjustToShowZero(minX, maxX, stepsX);\n      minX = _adjustToShowZero[0];\n      maxX = _adjustToShowZero[1];\n    } else {\n      var _adjustToShowZero2 = adjustToShowZero(minY, maxY, stepsY);\n      minY = _adjustToShowZero2[0];\n      maxY = _adjustToShowZero2[1];\n    }\n\n    // if options.direction is present, the results are delivered in { x, y }\n    // object structure. If options.direction is not present, the results are\n    // delivered in [x, y] array structure, for backwards compatibility\n    result = options.direction ? {\n      x: {\n        min: minX,\n        max: maxX\n      },\n      y: {\n        min: minY,\n        max: maxY\n      }\n    } : [[minX, maxX], [minY, maxY]];\n  } else {\n    result = options.direction ? {\n      x: {},\n      y: {}\n    } : [[], []];\n  }\n  return result;\n};\n\n// if options.direction is present, the results are delivered in { x, y }\n// object structure. If options.direction is not present, the results are\n// delivered in [x, y] array structure, for backwards compatibility\nexport var calcs = function calcs(values, options) {\n  if (values === void 0) {\n    values = [];\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var horizontal = options.direction === 'horizontal';\n\n  // the number of steps is one less than the number of labels\n  var _normalizeSteps2 = normalizeSteps(options.steps),\n    stepsX = _normalizeSteps2.x,\n    stepsY = _normalizeSteps2.y;\n\n  // bounds is { x: { min, max }, y: { min, max } } when options.direction is\n  // present and [[min, max], [min, max]] if not, for backwards compatibility\n  var bounds = options.bounds || calcBounds(values, options);\n  if (options.min !== undefined) {\n    if (options.direction) {\n      if (horizontal) bounds.x.min = options.min;else bounds.y.min = options.min;\n    } else bounds[1][0] = options.min;\n  }\n  if (options.max !== undefined) {\n    if (options.direction) {\n      if (horizontal) bounds.y.max = options.max;else bounds.x.max = options.max;\n    } else bounds[1][1] = options.max;\n  }\n  var _ref = options.direction ? bounds : {\n      x: {\n        min: bounds[0][0],\n        max: bounds[0][1]\n      },\n      y: {\n        min: bounds[1][0],\n        max: bounds[1][1]\n      }\n    },\n    _ref$x = _ref.x,\n    minX = _ref$x.min,\n    maxX = _ref$x.max,\n    _ref$y = _ref.y,\n    minY = _ref$y.min,\n    maxY = _ref$y.max;\n  var width = round(maxX - minX, 2);\n  var height = round(maxY - minY, 2);\n  var dimensions = options.direction ? {\n    width: width,\n    height: height\n  } : [width, height];\n\n  // Calculate x and y axis values across the specfied number of steps.\n  var yAxis = [];\n  var y = maxY;\n  // To deal with javascript math limitations, round the step with 4 decimal\n  // places and then push the values with 2 decimal places\n  var yStepInterval = round(height / stepsY, 4);\n  while (round(y, 2) >= minY) {\n    yAxis.push(round(y, 2));\n    y -= yStepInterval;\n  }\n  if (horizontal) yAxis.reverse();\n  var xAxis = [];\n  var x = minX;\n  var xStepInterval = round(width / stepsX, 4);\n  while (round(x, 2) <= maxX) {\n    xAxis.push(round(x, 2));\n    x += xStepInterval;\n  }\n  var _options = options,\n    thickness = _options.thickness;\n  if (!thickness) {\n    // Set bar thickness based on number of values being rendered.\n    // Someday, it would be better to include the actual rendered size.\n    // These values were emirically determined, trying to balance visibility\n    // and overlap across resolutions.\n    if (values.length < 5) {\n      thickness = 'xlarge';\n    } else if (values.length < 11) {\n      thickness = 'large';\n    } else if (values.length < 21) {\n      thickness = 'medium';\n    } else if (values.length < 61) {\n      thickness = 'small';\n    } else if (values.length < 121) {\n      thickness = 'xsmall';\n    } else {\n      thickness = 'hair';\n    }\n  }\n  var pad = thicknessPad[thickness];\n  return {\n    axis: options.direction ? {\n      x: xAxis,\n      y: yAxis\n    } : [xAxis, yAxis],\n    bounds: bounds,\n    dimensions: dimensions,\n    pad: pad,\n    thickness: thickness\n  };\n};","map":{"version":3,"names":["calcMinMax","normalizeValues","thicknessPad","xlarge","large","medium","small","xsmall","round","value","decimals","Number","Math","normalizeCoarseness","coarseness","direction","result","Array","isArray","x","y","undefined","normalizeSteps","steps","alignMax","interval","alignMin","adjustToShowZero","minArg","maxArg","min","max","abs","largest","stepInterval","minSteps","maxSteps","floor","ceil","calcBounds","valuesArg","options","_normalizeCoarseness","coarseX","coarseY","_normalizeSteps","stepsX","stepsY","values","length","_calcMinMax","_calcMinMax$x","minX","maxX","_calcMinMax$y","minY","maxY","deltaX","intervalX","parseFloat","toPrecision","deltaY","intervalY","_adjustToShowZero","_adjustToShowZero2","calcs","horizontal","_normalizeSteps2","bounds","_ref","_ref$x","_ref$y","width","height","dimensions","yAxis","yStepInterval","push","reverse","xAxis","xStepInterval","_options","thickness","pad","axis"],"sources":["/Users/kyle/node_modules/grommet/es6/components/Chart/calcs.js"],"sourcesContent":["import { calcMinMax, normalizeValues } from './utils';\nvar thicknessPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall'\n};\nexport var round = function round(value, decimals) {\n  return Number(Math.round(value + \"e\" + decimals) + \"e-\" + decimals);\n};\n\n// Normalize coarseness to an object.\n// Backwards compatible has no coarseness for x-axis.\nvar normalizeCoarseness = function normalizeCoarseness(coarseness, direction) {\n  var result;\n  if (Array.isArray(coarseness)) result = {\n    x: coarseness[0],\n    y: coarseness[1]\n  };else if (typeof coarseness === 'object') result = coarseness;else if (coarseness) result = {\n    x: undefined,\n    y: coarseness\n  };else result = direction === 'horizontal' ? {\n    x: 5,\n    y: undefined\n  } : {\n    x: undefined,\n    y: 5\n  };\n  return result;\n};\nvar normalizeSteps = function normalizeSteps(steps) {\n  var result;\n  if (Array.isArray(steps)) result = {\n    x: steps[0],\n    y: steps[1]\n  };else if (typeof steps === 'object') result = steps;else result = {\n    x: 1,\n    y: 1\n  };\n  return result;\n};\nvar alignMax = function alignMax(value, interval) {\n  if (value > 0) return value - value % interval + interval;\n  if (value < 0) return value + value % interval;\n  return value;\n};\nvar alignMin = function alignMin(value, interval) {\n  if (value > 0) return value - value % interval;\n  if (value < 0) return value - value % interval - interval;\n  return value;\n};\nvar adjustToShowZero = function adjustToShowZero(minArg, maxArg, steps) {\n  var min = minArg;\n  var max = maxArg;\n  if (min < 0 && max > 0 && Math.abs(min) !== Math.abs(max)) {\n    // Adjust min and max when crossing 0 to ensure 0 will be shown on\n    // the axis based on the number of steps.\n    if (steps === 1) {\n      var largest = Math.max(Math.abs(min), Math.abs(max));\n      min = -largest;\n      max = largest;\n    } else {\n      var stepInterval = (max - min) / steps;\n      var minSteps = min / stepInterval;\n      var maxSteps = max / stepInterval;\n      if (Math.abs(minSteps) < Math.abs(maxSteps)) {\n        // more above than below\n        stepInterval = max / Math.floor(maxSteps);\n        max = stepInterval * Math.floor(maxSteps);\n        min = stepInterval * Math.floor(minSteps);\n      } else {\n        // more below than above\n        stepInterval = Math.abs(min / Math.ceil(minSteps));\n        min = stepInterval * Math.ceil(minSteps);\n        max = stepInterval * Math.ceil(maxSteps);\n      }\n    }\n  }\n  return [min, max];\n};\nexport var calcBounds = function calcBounds(valuesArg, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // coarseness influences the rounding of the bounds, the smaller the\n  // number, the more the bounds will be rounded. e.g. 111 -> 110 -> 100.\n  var _normalizeCoarseness = normalizeCoarseness(options.coarseness, options.direction),\n    coarseX = _normalizeCoarseness.x,\n    coarseY = _normalizeCoarseness.y;\n\n  // the number of steps is one less than the number of labels\n  var _normalizeSteps = normalizeSteps(options.steps),\n    stepsX = _normalizeSteps.x,\n    stepsY = _normalizeSteps.y;\n  var values = normalizeValues(valuesArg || []);\n  var result;\n  if (values.length) {\n    // min and max values\n    var _calcMinMax = calcMinMax(values, options.direction),\n      _calcMinMax$x = _calcMinMax.x,\n      minX = _calcMinMax$x.min,\n      maxX = _calcMinMax$x.max,\n      _calcMinMax$y = _calcMinMax.y,\n      minY = _calcMinMax$y.min,\n      maxY = _calcMinMax$y.max;\n\n    // Calculate some reasonable bounds based on the max and min values.\n    // This is so values like 87342.12 don't end up being displayed as the\n    // graph axis labels.\n    if (coarseX) {\n      var deltaX = maxX - minX;\n      var intervalX = Number.parseFloat((deltaX / coarseX).toPrecision(1));\n      minX = alignMin(minX, intervalX);\n      maxX = alignMax(maxX, intervalX);\n    }\n    if (coarseY) {\n      var deltaY = maxY - minY;\n      var intervalY = Number.parseFloat((deltaY / coarseY).toPrecision(1));\n      minY = alignMin(minY, intervalY);\n      maxY = alignMax(maxY, intervalY);\n    }\n    if (options.direction === 'horizontal') {\n      var _adjustToShowZero = adjustToShowZero(minX, maxX, stepsX);\n      minX = _adjustToShowZero[0];\n      maxX = _adjustToShowZero[1];\n    } else {\n      var _adjustToShowZero2 = adjustToShowZero(minY, maxY, stepsY);\n      minY = _adjustToShowZero2[0];\n      maxY = _adjustToShowZero2[1];\n    }\n\n    // if options.direction is present, the results are delivered in { x, y }\n    // object structure. If options.direction is not present, the results are\n    // delivered in [x, y] array structure, for backwards compatibility\n    result = options.direction ? {\n      x: {\n        min: minX,\n        max: maxX\n      },\n      y: {\n        min: minY,\n        max: maxY\n      }\n    } : [[minX, maxX], [minY, maxY]];\n  } else {\n    result = options.direction ? {\n      x: {},\n      y: {}\n    } : [[], []];\n  }\n  return result;\n};\n\n// if options.direction is present, the results are delivered in { x, y }\n// object structure. If options.direction is not present, the results are\n// delivered in [x, y] array structure, for backwards compatibility\nexport var calcs = function calcs(values, options) {\n  if (values === void 0) {\n    values = [];\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var horizontal = options.direction === 'horizontal';\n\n  // the number of steps is one less than the number of labels\n  var _normalizeSteps2 = normalizeSteps(options.steps),\n    stepsX = _normalizeSteps2.x,\n    stepsY = _normalizeSteps2.y;\n\n  // bounds is { x: { min, max }, y: { min, max } } when options.direction is\n  // present and [[min, max], [min, max]] if not, for backwards compatibility\n  var bounds = options.bounds || calcBounds(values, options);\n  if (options.min !== undefined) {\n    if (options.direction) {\n      if (horizontal) bounds.x.min = options.min;else bounds.y.min = options.min;\n    } else bounds[1][0] = options.min;\n  }\n  if (options.max !== undefined) {\n    if (options.direction) {\n      if (horizontal) bounds.y.max = options.max;else bounds.x.max = options.max;\n    } else bounds[1][1] = options.max;\n  }\n  var _ref = options.direction ? bounds : {\n      x: {\n        min: bounds[0][0],\n        max: bounds[0][1]\n      },\n      y: {\n        min: bounds[1][0],\n        max: bounds[1][1]\n      }\n    },\n    _ref$x = _ref.x,\n    minX = _ref$x.min,\n    maxX = _ref$x.max,\n    _ref$y = _ref.y,\n    minY = _ref$y.min,\n    maxY = _ref$y.max;\n  var width = round(maxX - minX, 2);\n  var height = round(maxY - minY, 2);\n  var dimensions = options.direction ? {\n    width: width,\n    height: height\n  } : [width, height];\n\n  // Calculate x and y axis values across the specfied number of steps.\n  var yAxis = [];\n  var y = maxY;\n  // To deal with javascript math limitations, round the step with 4 decimal\n  // places and then push the values with 2 decimal places\n  var yStepInterval = round(height / stepsY, 4);\n  while (round(y, 2) >= minY) {\n    yAxis.push(round(y, 2));\n    y -= yStepInterval;\n  }\n  if (horizontal) yAxis.reverse();\n  var xAxis = [];\n  var x = minX;\n  var xStepInterval = round(width / stepsX, 4);\n  while (round(x, 2) <= maxX) {\n    xAxis.push(round(x, 2));\n    x += xStepInterval;\n  }\n  var _options = options,\n    thickness = _options.thickness;\n  if (!thickness) {\n    // Set bar thickness based on number of values being rendered.\n    // Someday, it would be better to include the actual rendered size.\n    // These values were emirically determined, trying to balance visibility\n    // and overlap across resolutions.\n    if (values.length < 5) {\n      thickness = 'xlarge';\n    } else if (values.length < 11) {\n      thickness = 'large';\n    } else if (values.length < 21) {\n      thickness = 'medium';\n    } else if (values.length < 61) {\n      thickness = 'small';\n    } else if (values.length < 121) {\n      thickness = 'xsmall';\n    } else {\n      thickness = 'hair';\n    }\n  }\n  var pad = thicknessPad[thickness];\n  return {\n    axis: options.direction ? {\n      x: xAxis,\n      y: yAxis\n    } : [xAxis, yAxis],\n    bounds: bounds,\n    dimensions: dimensions,\n    pad: pad,\n    thickness: thickness\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}