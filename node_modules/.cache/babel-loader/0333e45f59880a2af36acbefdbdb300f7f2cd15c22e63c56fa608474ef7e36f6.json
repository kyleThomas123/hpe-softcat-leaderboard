{"ast":null,"code":"import React, { useContext, useRef } from 'react';\nimport styled, { ThemeContext } from 'styled-components';\nimport { parseMetricToNum } from '../../utils';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { Box } from '../Box';\nimport { Stack } from '../Stack';\nimport { Text } from '../Text';\nvar StyledBadgeContainer = styled(Box).withConfig({\n  displayName: \"Badge__StyledBadgeContainer\",\n  componentId: \"sc-1es4ws1-0\"\n})([\"\", \"\"], function (props) {\n  return props.theme.button.badge.container.extend;\n});\nexport var Badge = function Badge(_ref) {\n  var children = _ref.children,\n    content = _ref.content;\n  var theme = useContext(ThemeContext);\n  var containerRef = useRef();\n  var contentRef = useRef();\n  var stackRef = useRef();\n  var defaultBadgeDimension = typeof content === 'boolean' || content && content.value && typeof content.value === 'boolean' ?\n  // empty badge should be smaller. this value was chosen as a default\n  // after experimenting with various values\n  parseMetricToNum(theme.button.badge.size.medium) / 2 + \"px\" : theme.button.badge.size.medium;\n\n  // scale badge to fit its contents, leaving space horizontally\n  // that is proportional to vertical space\n  useLayoutEffect(function () {\n    // when window resizes and hits a responsive breakpoint, width of the badge\n    // can change (because pad is responsive, etc.). we want to recalculate\n    // width since badge offset is reliant on its dimensions.\n    var onResize = function onResize() {\n      if (containerRef != null && containerRef.current) {\n        containerRef.current.style.minHeight = '';\n        containerRef.current.style.minWidth = '';\n        if (contentRef != null && contentRef.current) {\n          if (typeof content === 'number' || typeof content === 'object' && content.value) {\n            containerRef.current.style.minHeight = defaultBadgeDimension;\n            containerRef.current.style.minWidth = defaultBadgeDimension;\n            var _contentRef$current$g = contentRef.current.getBoundingClientRect(),\n              contentHeight = _contentRef$current$g.height,\n              contentWidth = _contentRef$current$g.width;\n\n            // only adjust the width if contentHeight > 0\n            // jest returns 0 for all getBoundingClientRect values,\n            // so this ensures snapshots are closer to correct values\n            if (contentHeight) {\n              // height of content includes extra space around font from\n              // line-height. account for this extra space with 2.5 multiplier\n              // to add proportional horizontal space\n              var height = defaultBadgeDimension;\n              var width = defaultBadgeDimension;\n              var verticalSpace = (parseMetricToNum(height) - contentHeight) * 2.5;\n              containerRef.current.style.minHeight = height;\n              containerRef.current.style.minWidth = Math.max(parseMetricToNum(width), Math.ceil(contentWidth + verticalSpace)) + \"px\";\n            }\n          } else {\n            // caller has provided custom JSX\n            containerRef.current.style.minHeight = contentRef.current.getBoundingClientRect().width;\n            containerRef.current.style.minWidth = contentRef.current.getBoundingClientRect().height;\n          }\n        } else {\n          containerRef.current.style.minHeight = defaultBadgeDimension;\n          containerRef.current.style.minWidth = defaultBadgeDimension;\n        }\n      }\n    };\n    window.addEventListener('resize', onResize);\n    onResize();\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [content, defaultBadgeDimension]);\n\n  // offset the badge so it overlaps content\n  useLayoutEffect(function () {\n    if (stackRef != null && stackRef.current) {\n      // when badge has content, offset should be 50%.\n      // when badge is empty, offset by a smaller amount to keep the badge\n      // closer to the content. this value was chosen as a reasonable default\n      // after testing with various grommet icons.\n      var offset = typeof content === 'boolean' || content && content.value === true ? '25%' : '50%';\n\n      // second child of Stack is the div that receives absolute positioning\n      // and contains our badge content\n      stackRef.current.children[1].style.top = 0;\n      stackRef.current.children[1].style.right = 0;\n      // eslint-disable-next-line max-len\n      stackRef.current.children[1].style.transform = \"translate(\" + offset + \", -\" + offset + \")\";\n      stackRef.current.children[1].style.transformOrigin = '100% 0%';\n    }\n  }, [content]);\n  var value;\n  if (typeof content === 'number') value = content;else if (typeof content === 'object') value = content.value;\n  var badge;\n  if (typeof value === 'number' || typeof value === 'boolean' || typeof content === 'boolean') {\n    if (typeof value === 'number') {\n      var max = content.max || 9;\n      badge = /*#__PURE__*/React.createElement(Text, {\n        color: \"text-strong\",\n        size: theme.button.badge.text.size.medium,\n        weight: \"normal\",\n        ref: contentRef\n      }, value > max ? max + \"+\" : value);\n    }\n    badge = /*#__PURE__*/React.createElement(StyledBadgeContainer, {\n      ref: containerRef,\n      align: \"center\",\n      background: content.background || theme.button.badge.container.background,\n      flex: false,\n      justify: \"center\",\n      round: true,\n      pad: !(typeof value === 'boolean' || typeof content === 'boolean') ? theme.button.badge.container.pad : undefined\n    }, badge);\n    // caller has provided their own JSX and we will just render that\n  } else badge = /*#__PURE__*/React.createElement(Box, {\n    ref: contentRef\n  }, content);\n  return /*#__PURE__*/React.createElement(Stack, {\n    ref: stackRef,\n    anchor: \"top-right\"\n  }, children, badge);\n};","map":{"version":3,"names":["React","useContext","useRef","styled","ThemeContext","parseMetricToNum","useLayoutEffect","Box","Stack","Text","StyledBadgeContainer","withConfig","displayName","componentId","props","theme","button","badge","container","extend","Badge","_ref","children","content","containerRef","contentRef","stackRef","defaultBadgeDimension","value","size","medium","onResize","current","style","minHeight","minWidth","_contentRef$current$g","getBoundingClientRect","contentHeight","height","contentWidth","width","verticalSpace","Math","max","ceil","window","addEventListener","removeEventListener","offset","top","right","transform","transformOrigin","createElement","color","text","weight","ref","align","background","flex","justify","round","pad","undefined","anchor"],"sources":["/Users/kyle/projects/personal/hpe-react-practice/node_modules/grommet/es6/components/Button/Badge.js"],"sourcesContent":["import React, { useContext, useRef } from 'react';\nimport styled, { ThemeContext } from 'styled-components';\nimport { parseMetricToNum } from '../../utils';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { Box } from '../Box';\nimport { Stack } from '../Stack';\nimport { Text } from '../Text';\nvar StyledBadgeContainer = styled(Box).withConfig({\n  displayName: \"Badge__StyledBadgeContainer\",\n  componentId: \"sc-1es4ws1-0\"\n})([\"\", \"\"], function (props) {\n  return props.theme.button.badge.container.extend;\n});\nexport var Badge = function Badge(_ref) {\n  var children = _ref.children,\n    content = _ref.content;\n  var theme = useContext(ThemeContext);\n  var containerRef = useRef();\n  var contentRef = useRef();\n  var stackRef = useRef();\n  var defaultBadgeDimension = typeof content === 'boolean' || content && content.value && typeof content.value === 'boolean' ? // empty badge should be smaller. this value was chosen as a default\n  // after experimenting with various values\n  parseMetricToNum(theme.button.badge.size.medium) / 2 + \"px\" : theme.button.badge.size.medium;\n\n  // scale badge to fit its contents, leaving space horizontally\n  // that is proportional to vertical space\n  useLayoutEffect(function () {\n    // when window resizes and hits a responsive breakpoint, width of the badge\n    // can change (because pad is responsive, etc.). we want to recalculate\n    // width since badge offset is reliant on its dimensions.\n    var onResize = function onResize() {\n      if (containerRef != null && containerRef.current) {\n        containerRef.current.style.minHeight = '';\n        containerRef.current.style.minWidth = '';\n        if (contentRef != null && contentRef.current) {\n          if (typeof content === 'number' || typeof content === 'object' && content.value) {\n            containerRef.current.style.minHeight = defaultBadgeDimension;\n            containerRef.current.style.minWidth = defaultBadgeDimension;\n            var _contentRef$current$g = contentRef.current.getBoundingClientRect(),\n              contentHeight = _contentRef$current$g.height,\n              contentWidth = _contentRef$current$g.width;\n\n            // only adjust the width if contentHeight > 0\n            // jest returns 0 for all getBoundingClientRect values,\n            // so this ensures snapshots are closer to correct values\n            if (contentHeight) {\n              // height of content includes extra space around font from\n              // line-height. account for this extra space with 2.5 multiplier\n              // to add proportional horizontal space\n              var height = defaultBadgeDimension;\n              var width = defaultBadgeDimension;\n              var verticalSpace = (parseMetricToNum(height) - contentHeight) * 2.5;\n              containerRef.current.style.minHeight = height;\n              containerRef.current.style.minWidth = Math.max(parseMetricToNum(width), Math.ceil(contentWidth + verticalSpace)) + \"px\";\n            }\n          } else {\n            // caller has provided custom JSX\n            containerRef.current.style.minHeight = contentRef.current.getBoundingClientRect().width;\n            containerRef.current.style.minWidth = contentRef.current.getBoundingClientRect().height;\n          }\n        } else {\n          containerRef.current.style.minHeight = defaultBadgeDimension;\n          containerRef.current.style.minWidth = defaultBadgeDimension;\n        }\n      }\n    };\n    window.addEventListener('resize', onResize);\n    onResize();\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [content, defaultBadgeDimension]);\n\n  // offset the badge so it overlaps content\n  useLayoutEffect(function () {\n    if (stackRef != null && stackRef.current) {\n      // when badge has content, offset should be 50%.\n      // when badge is empty, offset by a smaller amount to keep the badge\n      // closer to the content. this value was chosen as a reasonable default\n      // after testing with various grommet icons.\n      var offset = typeof content === 'boolean' || content && content.value === true ? '25%' : '50%';\n\n      // second child of Stack is the div that receives absolute positioning\n      // and contains our badge content\n      stackRef.current.children[1].style.top = 0;\n      stackRef.current.children[1].style.right = 0;\n      // eslint-disable-next-line max-len\n      stackRef.current.children[1].style.transform = \"translate(\" + offset + \", -\" + offset + \")\";\n      stackRef.current.children[1].style.transformOrigin = '100% 0%';\n    }\n  }, [content]);\n  var value;\n  if (typeof content === 'number') value = content;else if (typeof content === 'object') value = content.value;\n  var badge;\n  if (typeof value === 'number' || typeof value === 'boolean' || typeof content === 'boolean') {\n    if (typeof value === 'number') {\n      var max = content.max || 9;\n      badge = /*#__PURE__*/React.createElement(Text, {\n        color: \"text-strong\",\n        size: theme.button.badge.text.size.medium,\n        weight: \"normal\",\n        ref: contentRef\n      }, value > max ? max + \"+\" : value);\n    }\n    badge = /*#__PURE__*/React.createElement(StyledBadgeContainer, {\n      ref: containerRef,\n      align: \"center\",\n      background: content.background || theme.button.badge.container.background,\n      flex: false,\n      justify: \"center\",\n      round: true,\n      pad: !(typeof value === 'boolean' || typeof content === 'boolean') ? theme.button.badge.container.pad : undefined\n    }, badge);\n    // caller has provided their own JSX and we will just render that\n  } else badge = /*#__PURE__*/React.createElement(Box, {\n    ref: contentRef\n  }, content);\n  return /*#__PURE__*/React.createElement(Stack, {\n    ref: stackRef,\n    anchor: \"top-right\"\n  }, children, badge);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}